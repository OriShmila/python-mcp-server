# MCP Server Template Rules

## 🎯 Purpose
This document provides implementation guidelines for creating **UNIQUE** MCP (Model Context Protocol) servers using this Python template. Follow these rules to ensure proper implementation and avoid conflicts.

## ⚠️ CRITICAL RULES - START HERE

### 0. Make Your Server UNIQUE (Most Important!)
**🚨 BEFORE ANYTHING ELSE - Rename the package folder:**
```bash
# Rename mcp_server to YOUR unique name - NAME MUST BE THE NAME OF ROOT FOLDER AS PASCAL CASE.
mv mcp_server weather_mcp_server 

# Then update imports in these files (look for 🎯 template markers):
# - my_weather_server/server.py (line 18)  
# - main.py (line 11)
# - pyproject.toml (lines 41, 65, 67, 71)
```

**Why this matters:**
- Prevents import conflicts when multiple MCP servers are installed
- Makes your server identifiable in logs and client configurations
- Required for proper packaging and distribution

### 1. Schema Definition - NEVER USE JSON.stringify()
**❌ WRONG - Never do this:**
```python
# DON'T stringify schemas
inputSchema = json.dumps({"type": "object", ...})
```

**✅ CORRECT - Always use proper dict/object:**
```python
# Define schemas as Python dicts in tools.json
{
  "inputSchema": {
    "type": "object",
    "properties": {
      "param": {"type": "string"}
    }
  }
}
```

### 2. Tool Implementation Pattern
Always follow this structure in `handlers.py`:
```python
async def your_tool_function(param1: str, param2: int = None) -> dict:
    """Tool description with proper error handling."""
    # 1. Input validation
    if not param1:
        raise ValueError("param1 is required")
    
    # 2. Process request
    result = await process_data(param1, param2)
    
    # 3. Return structured response matching outputSchema
    return {"field": "value"}  # Must match outputSchema

# Register in TOOL_FUNCTIONS
TOOL_FUNCTIONS = {
    "your_tool": your_tool_function,
}
```

## 📁 FILES TO MODIFY (Required Changes)

### 1. `your_server_name/tools.json` ✏️
**Purpose:** Define all tool schemas  
**Current State:** Contains 2 example weather tools (get_weather, search_locations)
**Changes Required:**
- Follow 🎯 template instructions in the file
- Remove ALL weather example tools 
- Replace with YOUR actual tools
- Update server name from "YourServerName"
- Define proper inputSchema and outputSchema for each tool
- Use JSON Schema format (no stringification!)

```json
{
  "name": "YourServerName",
  "tools": [
    {
      "name": "your_tool_name",
      "description": "Clear description of what this tool does",
      "inputSchema": {
        "type": "object",
        "properties": {
          "required_param": {
            "type": "string",
            "description": "What this parameter does"
          },
          "optional_param": {
            "type": "integer",
            "description": "Optional parameter",
            "default": 10
          }
        },
        "required": ["required_param"]
      },
      "outputSchema": {
        "type": "object",
        "description": "What this tool returns",
        "properties": {
          "result": {"type": "string"},
          "data": {"type": "object"}
        }
      }
    }
  ]
}
```

### 2. `your_server_name/handlers.py` ✏️
**Purpose:** Implement tool functions
**Current State:** Contains 2 example weather functions with template instructions
**Changes Required:**
- Follow 🎯 template instructions in the file
- Remove ALL Weather API example code (marked as "WEATHER EXAMPLE")
- Remove weather imports (httpx, dotenv) if not needed
- Implement YOUR tool functions
- Update TOOL_FUNCTIONS mapping (currently has only 2 tools)
- Add proper async/await handling
- Include error handling

```python
# Remove example imports
# Remove: import httpx, from dotenv import load_dotenv

# Add your imports
import your_dependencies

# Implement your tools
async def your_tool_name(required_param: str, optional_param: int = 10) -> dict:
    """Implementation matching the schema."""
    # Your implementation
    return {"result": "success", "data": {}}

# Update mapping
TOOL_FUNCTIONS = {
    "your_tool_name": your_tool_name,
}
```

### 3. `your_server_name/server.py` ✏️
**Purpose:** Core server implementation  
**Changes Required:**
- Follow 🎯 template instructions at the top of the file
- Update import on line 18 when you rename the folder
- Update server name and logger name (lines 21, 44)
- Update server version in line 87
- Keep the core structure intact

```python
server = Server("YourServerName")  # Line 44
# ...
server_version="0.1.0",  # Line 87 - update version
```

### 4. `test_cases.json` ✏️
**Purpose:** Define test scenarios
**Current State:** Contains 12 test cases for 2 example weather tools with template instructions
**Changes Required:**
- Follow 🎯 template instructions in the file
- Remove ALL Weather API test cases (marked as examples)
- Add test cases for each of YOUR tools
- Include both success and failure cases
- Use the provided template patterns

```json
{
  "test_cases": [
    {
      "name": "test_your_tool_success",
      "tool": "your_tool_name",
      "arguments": {
        "required_param": "test_value"
      },
      "description": "Test successful execution",
      "expected_fields": ["result", "data"],
      "should_succeed": true
    },
    {
      "name": "test_your_tool_missing_param",
      "tool": "your_tool_name",
      "arguments": {},
      "description": "Test missing required parameter",
      "expected_fields": [],
      "should_succeed": false
    }
  ]
}
```

### 5. `pyproject.toml` ✏️
**Purpose:** Project configuration
**Changes Required:**
- Follow 🎯 template instructions at the top
- Update project name (line 16) to your unique kebab-case name
- Update folder references (lines 41, 65, 67, 71) when you rename mcp_server
- Update description and version
- Remove unused dependencies (httpx, python-dotenv if not needed)
- Add your specific dependencies
- Update console script name

```toml
[project]
name = "your-mcp-server"
version = "0.1.0"
description = "Your MCP server description"
readme = "README.md"
requires-python = ">=3.11"
dependencies = [
    "mcp>=1.6.0",
    # Remove unused dependencies (httpx, etc.)
    # Add your dependencies
]

[project.scripts]
your-server = "mcp_server.__main__:main"
```

### 6. `.env.example` ✏️ (Already exists)
**Purpose:** Example environment configuration  
**Current State:** Contains comprehensive environment variable examples with template instructions
**Changes Required:**
- Follow template instructions in the file
- Remove weather-specific variables if not needed
- Add your actual environment variables
- Update examples to match your use case

```bash
# Example environment variables for your MCP server
# Copy this file to .env and fill in actual values

# YOUR_API_KEY=your_actual_api_key_here
# YOUR_CONFIG_VAR=config_value
# DEBUG=false
```

### 7. `README.md` ✏️
**Purpose:** Documentation
**Current State:** Updated with template instructions and folder renaming guidance
**Changes Required:**
- Update title and description for your specific server
- Replace weather API examples with your tool examples  
- Update installation instructions if needed
- Document your specific environment variables
- Update usage examples for your tools

## 📁 FILES TO KEEP AS-IS (Template Core)

### ✅ DO NOT MODIFY (except for folder rename updates):
- `your_server_name/__init__.py` - Package initialization  
- `your_server_name/__main__.py` - Entry point (has 🎯 template instructions)
- `main.py` - Testing compatibility wrapper (has 🎯 template instructions for import update)
- `test_server.py` - Test framework (works with any tools, has 🎯 template instructions)
- `uv.lock` - Will auto-update when you change dependencies

## 📁 FILES TO CREATE

### 1. `.env` 🆕 (User must create, DO NOT commit)
```bash
# Actual environment variables
YOUR_API_KEY=actual_key_here
```

### 2. `.gitignore` 🆕 (If not exists)
```
.env
__pycache__/
*.pyc
.pytest_cache/
*.egg-info/
dist/
build/
```

## 🚫 REMOVE OLD CODE CHECKLIST

When adapting this template, remove (all marked as examples in files):

1. **From `your_server_name/handlers.py`:**
   - [ ] All Weather API imports (`httpx`, `dotenv`) - marked as "WEATHER EXAMPLE IMPORTS"
   - [ ] All weather-related functions - marked as "WEATHER EXAMPLE" 
   - [ ] Weather API key loading
   - [ ] Weather-specific error handling
   - [ ] All template comments after implementation

2. **From `your_server_name/tools.json`:**
   - [ ] All weather tool definitions - marked with "_example_note" 
   - [ ] Weather-specific schema definitions
   - [ ] All template instruction sections starting with "_"

3. **From `test_cases.json`:**
   - [ ] All weather API test cases - marked with "_example_note"
   - [ ] Weather-specific test scenarios  
   - [ ] All template instruction sections starting with "_"

4. **From `pyproject.toml`:**
   - [ ] Unused dependencies (httpx if not needed)
   - [ ] Template instruction comments

## ✅ IMPLEMENTATION CHECKLIST

Follow this order when implementing your MCP server:

0. **Uniqueness Phase (CRITICAL FIRST!):**
   - [ ] Rename `mcp_server` folder to your unique name (e.g., `weather_server`)
   - [ ] Update imports following 🎯 template instructions in files
   - [ ] Test that server still works: `uv run python test_server.py`

1. **Planning Phase:**
   - [ ] Define what tools you need (study the 2 example tools first)
   - [ ] Design input/output schemas
   - [ ] Identify required dependencies

2. **Schema Phase:**
   - [ ] Edit `your_server_name/tools.json` following 🎯 instructions
   - [ ] Remove weather example tools
   - [ ] Add your tool schemas  
   - [ ] Validate schemas are proper JSON (not stringified)
   - [ ] Ensure all required fields are defined

3. **Implementation Phase:**
   - [ ] Clean out weather example code from `your_server_name/handlers.py`
   - [ ] Remove weather imports if not needed
   - [ ] Implement each tool function
   - [ ] Add error handling
   - [ ] Update TOOL_FUNCTIONS mapping

4. **Configuration Phase:**
   - [ ] Update `pyproject.toml` following 🎯 instructions
   - [ ] Add/remove dependencies as needed
   - [ ] Update `.env.example` with your variables
   - [ ] Update server name and logger in `server.py`

5. **Testing Phase:**
   - [ ] Remove weather test cases from `test_cases.json`
   - [ ] Write test cases for your tools
   - [ ] Run tests: `uv run python test_server.py`
   - [ ] Fix any validation errors

6. **Documentation Phase:**
   - [ ] Update README.md for your server
   - [ ] Document all environment variables
   - [ ] Add usage examples for your tools

7. **Integration Phase:**
   - [ ] Test with MCP client (Claude Desktop, etc.)
   - [ ] Verify all tools appear and work
   - [ ] Check error handling

8. **Cleanup Phase (Final Step):**
   - [ ] Remove all 🎯 template instruction markers from code files
   - [ ] Remove template comments marked as "WEATHER EXAMPLE" or "_example_note"
   - [ ] Remove "_" prefixed instruction sections from JSON files
   - [ ] Clean up any remaining TODO/FIXME comments from template
   - [ ] Verify no template-specific content remains in production code
   - [ ] Update this .cursorrules file to reflect your actual server implementation

## 🎯 COMMON MISTAKES TO AVOID

### ❌ DON'T:
1. **Stringify schemas** - Always use dict/object format
2. **Forget async** - Tool functions should be async
3. **Skip validation** - Always validate inputs
4. **Ignore schemas** - Output must match outputSchema
5. **Hardcode secrets** - Use environment variables
6. **Modify test framework** - `test_server.py` works as-is
7. **Break MCP protocol** - Keep server.py structure intact

### ✅ DO:
1. **Make your server unique** - Rename folder and update imports FIRST
2. **Follow template instructions** - Look for 🎯 markers in every file
3. **Define clear schemas** - Be explicit about types
4. **Handle errors gracefully** - Return meaningful errors
5. **Test thoroughly** - Cover success and failure cases
6. **Document everything** - Clear descriptions in schemas
7. **Use type hints** - Python type annotations
8. **Follow async patterns** - Proper async/await usage
9. **Validate inputs** - Check required parameters

## 🔍 VALIDATION RULES

### Input Validation:
```python
# Always validate required parameters
if not required_param:
    raise ValueError("required_param is required")

# Validate parameter types and ranges
if days < 1 or days > 30:
    raise ValueError("days must be between 1 and 30")
```

### Output Validation:
```python
# Output MUST match outputSchema structure
return {
    "field1": "value",  # Required field from schema
    "field2": {         # Nested object as defined in schema
        "subfield": 123
    }
}
```

## 📊 SCHEMA FORMAT REFERENCE

### Correct Schema Format:
```json
{
  "inputSchema": {
    "type": "object",
    "properties": {
      "text": {
        "type": "string",
        "description": "Input text",
        "minLength": 1,
        "maxLength": 1000
      },
      "count": {
        "type": "integer",
        "minimum": 1,
        "maximum": 100,
        "default": 10
      },
      "options": {
        "type": "array",
        "items": {"type": "string"}
      }
    },
    "required": ["text"]
  }
}
```

### Schema Types:
- `string` - Text values
- `integer` - Whole numbers
- `number` - Decimal numbers  
- `boolean` - true/false
- `object` - Nested structures
- `array` - Lists of items

### Schema Constraints:
- `required` - Required fields array
- `default` - Default values
- `minimum`/`maximum` - Number ranges
- `minLength`/`maxLength` - String length
- `pattern` - Regex patterns
- `enum` - Allowed values

## 🚀 QUICK START COMMANDS

```bash
# 1. Make your server unique (CRITICAL FIRST STEP!)
mv mcp_server my_awesome_server  # Use YOUR unique name
# Then update imports following 🎯 template instructions

# 2. Install dependencies
uv sync

# 3. Test the template works with your renamed folder
uv run python test_server.py

# 4. Create .env from example
cp .env.example .env
# Edit .env with your values

# 5. Customize your server following 🎯 instructions in each file

# 6. Test your implementation
uv run python test_server.py

# 7. Run the server
uv run python main.py

# 8. Package for distribution
uv build
```

## 📝 MCP CLIENT CONFIGURATION

Configure your MCP client (e.g., Claude Desktop):

```json
{
  "mcpServers": {
    "your-server": {
      "command": "uvx",
      "args": [
        "--from",
        "git+https://github.com/yourusername/your-mcp-server",
        "your-server"
      ],
      "env": {
        "YOUR_API_KEY": "your_key_here"
      }
    }
  }
}
```

## 🔗 HELPFUL RESOURCES

- [MCP Specification](https://github.com/modelcontextprotocol)
- [JSON Schema Docs](https://json-schema.org/learn/getting-started-step-by-step)
- [Python Async Guide](https://realpython.com/async-io-python/)
- [UV Package Manager](https://github.com/astral-sh/uv)

---

**Remember:** The key to a successful MCP server is proper schema definition and validation. Never stringify schemas, always use proper object format, and ensure your outputs match your defined schemas exactly.
